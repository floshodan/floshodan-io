{
  "title": "Advent of Code in Assembly",
  "date": "2022-12-03T00:00:00.000Z",
  "summary": "Advent Of Code Day 01 in x86 Assembly language",
  "image": "blog4.jpg",
  "featured": "true",
  "body": {
    "raw": "\nI think the Advent of Code challenges are a wonderful opportunity to experiment with new programming languages. As I have been trying to learn more about operating systems and the low level operations of computers, I thought it would be an interesting exercise to try to complete some of the Advent of Code 2020 challenges in x86-64 assembly on Linux.\n\n## Preface\n\nthis is a[Link text Here](https://link-url-here.org)\n\nI will be going through my assembly solution to the Advent of Code 2020 Day 01 challenge. Along the way, I will attempt to explain what assembly is, why it is important, and how the code works.\n\nI expect that you will already have some experience with programming. This doesn't have to be low level programming or assembly or anything like that, although that would help tremendously. If you have a decent amount of experience in programming languages such as Python or Javascript, you may have to follow along slowly, but you should hopefully be able to understand the code.\n\nIf you would like to follow along with me, you will need\n\n- the nasm x86 assembler\n- the gcc compiler\n- the make build tool\n- I leave the installation of these tools to you.\n\n## GDB\n\nWhile optional, I would recommend you also install the gdb debugger. This was invaluable to me when writing this post, as my code would frequently crash or justs not work. Using gdb is outside the scope of this post, but there are plenty of guides online. If you do decide to use gdb, I would recommending using layout asm, layout regs, and set disassembly-flavor intel; this will display the register values and assembly code in Intel syntax in separate windows. You may find it annoying to type these commands in at the start of every debugging session, in which case you can copy the following into .gdbinit in your home directory:\n\n```bash\nset auto-load safe-path /\nset disassembly-flavor intel\n\nlayout regs\nlayout asm\n```\n\n# Introduction\n\nTo execute a program, your CPU accepts machine code instructions. These are raw bytes that instruct the CPU to perform one of the low level operations it knows how to do -- such as access memory, perform basic arithmetic, move data into registers, etc.\n\nWhile programmers did write raw machine code in some of the earliest days in computing, almost no one writes raw machine code today. Machine code is incredibly difficult for humans to read, write, and understand because it is merely a sequence of numbers encoded in binary that is sent to the CPU. Imagine encoding the English alphabet with the numbers 1-26 and trying to write a paper using those numbers in place of letters. While it is possible, it would take an exorbitant amount of time and likely be fraught with errors.\n\nThese early computer scientists soon developed assembly as an abstraction on top of machine code. Instead of writing the sequence of numbers that would encode machine code instructions, code would be written with text that humans could better read and understand. Each line would encode one instruction and any arguments that instruction would accept. Labels were also added so that code could refer to certain parts of the program in a simple way, allowing programmers to more easily implement loops, functions, conditional statements, etc.\n\nHowever, assembly cannot be executed by the CPU -- the CPU can only execute machine code. Thus, assembly must be assembled into machine code by an assembler. An assembler is essentially a compiler from assembly to machine code. This machine code can then be sent to the CPU and executed.\n\nAs assembly is only a light abstraction over machine code, it is highly processor-specific and low level. That means that assembly code must take certain features of the CPU into account to work properly, such as the architecture, registers, addressing modes, data types, and more.\n\nWe will be writing code for the x86 architecture, targeting CPUs with 64 bit registers. This is usually succinctly described as x86-64 assembly code.\n\nFurthermore, as we are not writing assembly for a bare metal application, we rely on interfacing with the operating system to perform many operations, such as opening, reading from, writing to, and closing files. The interface to perform these operations through the operating system are operating system specific, so we will be targeting Linux in this article.\n\n# Assembly Basics\n\nWe will first review some preliminary aspects of assembly code that are required to read or write any assembly.\n\n## registers\n\nMuch of assembly code performs operations with registers. Registers are small memory locations within the CPU that store the data that the CPU performs operations on. For instance, when performing an add operation, one of the operands must be CPU register that the CPU will save the final sum to.\n\nCPU registers are typically either 8 bit, 16 bit, 32 bit, or 64 bit. Most modern desktop processors today are 64 bit, and as stated before, we are writing 64 bit assembly code.\n\nThese registers are all referred to with special, and somewhat confusing, names in assembly code.\n\nThe table here lists all of the x86-64 registers.\n\nNote that although these registers are 64 bit, you can specifically access smaller portions of the registers. For example, here are all of the subparts of the 64 bit rax register:\n\n- `rax`: the full 64 bit register\n- `eax` : the lower 32 bits of `rax`\n- `ax` : the lowest 16 bits of `rax`\n- `ah` : the upper 8 bits of `ax`\n- `al` : the lower 8 bits of `ax` / the lowest 8 bits of `rax` You can find all of these names, as well as the names of the other registers, in the link above.\n- `Note` that you cannot access the highest 32 bits of `rax` nor the highest 16 bits of eax directly. You can compute their values using bit operations, but their values cannot be accessed directly.\n\nWe can move data into registers with the mov class of instructions.\n\n```asm\nmov rax, 0xdeadbeef ; move the number 0xdeadbeef into rax\nmov eax, 42         ; move the number 42 into eax, the lower 32 bits of rax\nmov ax, 0xff        ; move the number 0xff into ax, the lowest 16 bits of rax\nmov ah, 0xf         ; move the number 0xf into ah, the high 8 bits of ax\nmov al, 0xa         ; move the number 0xa into al, the low 8 bits of ax\n```\n\n## Instructions\n\nWe should now discuss instructions.\n\nEvery line of an assembly program encodes exactly one assembly instruction. An instruction is an one operation that a CPU executes. Most instructions additionally take one or more operands, which are arguments that specify the operation of the instruction. For instance, the mov instruction showed above takes a register as its first operand and a number as its second operand. This encodes the operation of moving the number into the register. There are different forms of many instructions, however, that accept different operands; for instance, each line above is a different form of mov, as it accepts a different size of register. This means that the machine code number of the mov instruction is different on each line. Thus, each form of an instruction is encoded by a different number in machine code.\n\nWe do not have to worry too much about the different forms of instructions and their machine code numbers to write simple assembly code, thankfully. Just be aware that there are many assembly instructions and each instruction can take none, one, or more operands.\n\nThe mov instruction discussed above, generally, moves data from a source to a destination of equal size in the form mov [dest] [src].\n",
    "code": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var o in e)s(t,o,{get:e[o],enumerable:!0})},r=(t,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!y.call(t,a)&&a!==o&&s(t,a,{get:()=>e[a],enumerable:!(i=m(e,a))||i.enumerable});return t};var g=(t,e,o)=>(o=t!=null?d(u(t)):{},r(e||!t||!t.__esModule?s(o,\"default\",{value:t,enumerable:!0}):o,t)),w=t=>r(s({},\"__esModule\",{value:!0}),t);var c=f((F,l)=>{l.exports=_jsx_runtime});var A={};b(A,{default:()=>v,frontmatter:()=>B});var n=g(c()),B={title:\"Advent of Code in Assembly\",date:\"2022-12-03\",summary:\"Advent Of Code Day 01 in x86 Assembly language\",image:\"blog4.jpg\",featured:\"true\"};function h(t){let e=Object.assign({p:\"p\",h2:\"h2\",a:\"a\",span:\"span\",ul:\"ul\",li:\"li\",div:\"div\",pre:\"pre\",code:\"code\",h1:\"h1\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"I think the Advent of Code challenges are a wonderful opportunity to experiment with new programming languages. As I have been trying to learn more about operating systems and the low level operations of computers, I thought it would be an interesting exercise to try to complete some of the Advent of Code 2020 challenges in x86-64 assembly on Linux.\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"preface\",children:[(0,n.jsx)(e.a,{className:\"subheading-anchor\",\"aria-label\":\"Link to section\",href:\"#preface\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Preface\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"this is a\",(0,n.jsx)(e.a,{href:\"https://link-url-here.org\",children:\"Link text Here\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"I will be going through my assembly solution to the Advent of Code 2020 Day 01 challenge. Along the way, I will attempt to explain what assembly is, why it is important, and how the code works.\"}),`\n`,(0,n.jsx)(e.p,{children:\"I expect that you will already have some experience with programming. This doesn't have to be low level programming or assembly or anything like that, although that would help tremendously. If you have a decent amount of experience in programming languages such as Python or Javascript, you may have to follow along slowly, but you should hopefully be able to understand the code.\"}),`\n`,(0,n.jsx)(e.p,{children:\"If you would like to follow along with me, you will need\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"the nasm x86 assembler\"}),`\n`,(0,n.jsx)(e.li,{children:\"the gcc compiler\"}),`\n`,(0,n.jsx)(e.li,{children:\"the make build tool\"}),`\n`,(0,n.jsx)(e.li,{children:\"I leave the installation of these tools to you.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.h2,{id:\"gdb\",children:[(0,n.jsx)(e.a,{className:\"subheading-anchor\",\"aria-label\":\"Link to section\",href:\"#gdb\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"GDB\"]}),`\n`,(0,n.jsx)(e.p,{children:\"While optional, I would recommend you also install the gdb debugger. This was invaluable to me when writing this post, as my code would frequently crash or justs not work. Using gdb is outside the scope of this post, but there are plenty of guides online. If you do decide to use gdb, I would recommending using layout asm, layout regs, and set disassembly-flavor intel; this will display the register values and assembly code in Intel syntax in separate windows. You may find it annoying to type these commands in at the start of every debugging session, in which case you can copy the following into .gdbinit in your home directory:\"}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"bash\",\"data-theme\":\"default\",children:(0,n.jsxs)(e.code,{\"data-language\":\"bash\",\"data-theme\":\"default\",children:[(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#56B6C2\"},children:\"set\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#98C379\"},children:\"auto-load\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#98C379\"},children:\"safe-path\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#98C379\"},children:\"/\"})]}),`\n`,(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#56B6C2\"},children:\"set\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#98C379\"},children:\"disassembly-flavor\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#98C379\"},children:\"intel\"})]}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:\" \"}),`\n`,(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\"layout \"}),(0,n.jsx)(e.span,{style:{color:\"#98C379\"},children:\"regs\"})]}),`\n`,(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\"layout \"}),(0,n.jsx)(e.span,{style:{color:\"#98C379\"},children:\"asm\"})]})]})})}),`\n`,(0,n.jsxs)(e.h1,{id:\"introduction\",children:[(0,n.jsx)(e.a,{className:\"subheading-anchor\",\"aria-label\":\"Link to section\",href:\"#introduction\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Introduction\"]}),`\n`,(0,n.jsx)(e.p,{children:\"To execute a program, your CPU accepts machine code instructions. These are raw bytes that instruct the CPU to perform one of the low level operations it knows how to do -- such as access memory, perform basic arithmetic, move data into registers, etc.\"}),`\n`,(0,n.jsx)(e.p,{children:\"While programmers did write raw machine code in some of the earliest days in computing, almost no one writes raw machine code today. Machine code is incredibly difficult for humans to read, write, and understand because it is merely a sequence of numbers encoded in binary that is sent to the CPU. Imagine encoding the English alphabet with the numbers 1-26 and trying to write a paper using those numbers in place of letters. While it is possible, it would take an exorbitant amount of time and likely be fraught with errors.\"}),`\n`,(0,n.jsx)(e.p,{children:\"These early computer scientists soon developed assembly as an abstraction on top of machine code. Instead of writing the sequence of numbers that would encode machine code instructions, code would be written with text that humans could better read and understand. Each line would encode one instruction and any arguments that instruction would accept. Labels were also added so that code could refer to certain parts of the program in a simple way, allowing programmers to more easily implement loops, functions, conditional statements, etc.\"}),`\n`,(0,n.jsx)(e.p,{children:\"However, assembly cannot be executed by the CPU -- the CPU can only execute machine code. Thus, assembly must be assembled into machine code by an assembler. An assembler is essentially a compiler from assembly to machine code. This machine code can then be sent to the CPU and executed.\"}),`\n`,(0,n.jsx)(e.p,{children:\"As assembly is only a light abstraction over machine code, it is highly processor-specific and low level. That means that assembly code must take certain features of the CPU into account to work properly, such as the architecture, registers, addressing modes, data types, and more.\"}),`\n`,(0,n.jsx)(e.p,{children:\"We will be writing code for the x86 architecture, targeting CPUs with 64 bit registers. This is usually succinctly described as x86-64 assembly code.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Furthermore, as we are not writing assembly for a bare metal application, we rely on interfacing with the operating system to perform many operations, such as opening, reading from, writing to, and closing files. The interface to perform these operations through the operating system are operating system specific, so we will be targeting Linux in this article.\"}),`\n`,(0,n.jsxs)(e.h1,{id:\"assembly-basics\",children:[(0,n.jsx)(e.a,{className:\"subheading-anchor\",\"aria-label\":\"Link to section\",href:\"#assembly-basics\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Assembly Basics\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We will first review some preliminary aspects of assembly code that are required to read or write any assembly.\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"registers\",children:[(0,n.jsx)(e.a,{className:\"subheading-anchor\",\"aria-label\":\"Link to section\",href:\"#registers\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"registers\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Much of assembly code performs operations with registers. Registers are small memory locations within the CPU that store the data that the CPU performs operations on. For instance, when performing an add operation, one of the operands must be CPU register that the CPU will save the final sum to.\"}),`\n`,(0,n.jsx)(e.p,{children:\"CPU registers are typically either 8 bit, 16 bit, 32 bit, or 64 bit. Most modern desktop processors today are 64 bit, and as stated before, we are writing 64 bit assembly code.\"}),`\n`,(0,n.jsx)(e.p,{children:\"These registers are all referred to with special, and somewhat confusing, names in assembly code.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The table here lists all of the x86-64 registers.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Note that although these registers are 64 bit, you can specifically access smaller portions of the registers. For example, here are all of the subparts of the 64 bit rax register:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"rax\"}),\": the full 64 bit register\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"eax\"}),\" : the lower 32 bits of \",(0,n.jsx)(e.code,{children:\"rax\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"ax\"}),\" : the lowest 16 bits of \",(0,n.jsx)(e.code,{children:\"rax\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"ah\"}),\" : the upper 8 bits of \",(0,n.jsx)(e.code,{children:\"ax\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"al\"}),\" : the lower 8 bits of \",(0,n.jsx)(e.code,{children:\"ax\"}),\" / the lowest 8 bits of \",(0,n.jsx)(e.code,{children:\"rax\"}),\" You can find all of these names, as well as the names of the other registers, in the link above.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Note\"}),\" that you cannot access the highest 32 bits of \",(0,n.jsx)(e.code,{children:\"rax\"}),\" nor the highest 16 bits of eax directly. You can compute their values using bit operations, but their values cannot be accessed directly.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"We can move data into registers with the mov class of instructions.\"}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"asm\",\"data-theme\":\"default\",children:(0,n.jsxs)(e.code,{\"data-language\":\"asm\",\"data-theme\":\"default\",children:[(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#C678DD\"},children:\"mov\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"rax\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\", \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"0xdeadbeef\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#7F848E\",fontStyle:\"italic\"},children:\"; move the number 0xdeadbeef into rax\"})]}),`\n`,(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#C678DD\"},children:\"mov\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"eax\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\", \"}),(0,n.jsx)(e.span,{style:{color:\"#C678DD\"},children:\"42\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\"         \"}),(0,n.jsx)(e.span,{style:{color:\"#7F848E\",fontStyle:\"italic\"},children:\"; move the number 42 into eax, the lower 32 bits of rax\"})]}),`\n`,(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#C678DD\"},children:\"mov\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"ax\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\", \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"0xff\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\"        \"}),(0,n.jsx)(e.span,{style:{color:\"#7F848E\",fontStyle:\"italic\"},children:\"; move the number 0xff into ax, the lowest 16 bits of rax\"})]}),`\n`,(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#C678DD\"},children:\"mov\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"ah\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\", \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"0xf\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\"         \"}),(0,n.jsx)(e.span,{style:{color:\"#7F848E\",fontStyle:\"italic\"},children:\"; move the number 0xf into ah, the high 8 bits of ax\"})]}),`\n`,(0,n.jsxs)(e.span,{className:\"line\",children:[(0,n.jsx)(e.span,{style:{color:\"#C678DD\"},children:\"mov\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\" \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"al\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\", \"}),(0,n.jsx)(e.span,{style:{color:\"#D19A66\"},children:\"0xa\"}),(0,n.jsx)(e.span,{style:{color:\"#ABB2BF\"},children:\"         \"}),(0,n.jsx)(e.span,{style:{color:\"#7F848E\",fontStyle:\"italic\"},children:\"; move the number 0xa into al, the low 8 bits of ax\"})]})]})})}),`\n`,(0,n.jsxs)(e.h2,{id:\"instructions\",children:[(0,n.jsx)(e.a,{className:\"subheading-anchor\",\"aria-label\":\"Link to section\",href:\"#instructions\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Instructions\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We should now discuss instructions.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Every line of an assembly program encodes exactly one assembly instruction. An instruction is an one operation that a CPU executes. Most instructions additionally take one or more operands, which are arguments that specify the operation of the instruction. For instance, the mov instruction showed above takes a register as its first operand and a number as its second operand. This encodes the operation of moving the number into the register. There are different forms of many instructions, however, that accept different operands; for instance, each line above is a different form of mov, as it accepts a different size of register. This means that the machine code number of the mov instruction is different on each line. Thus, each form of an instruction is encoded by a different number in machine code.\"}),`\n`,(0,n.jsx)(e.p,{children:\"We do not have to worry too much about the different forms of instructions and their machine code numbers to write simple assembly code, thankfully. Just be aware that there are many assembly instructions and each instruction can take none, one, or more operands.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The mov instruction discussed above, generally, moves data from a source to a destination of equal size in the form mov [dest] [src].\"})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var v=x;return w(A);})();\n;return Component;"
  },
  "_id": "posts/advent-of-code-assembly.mdx",
  "_raw": {
    "sourceFilePath": "posts/advent-of-code-assembly.mdx",
    "sourceFileName": "advent-of-code-assembly.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/advent-of-code-assembly"
  },
  "type": "Post",
  "readingTime": {
    "text": "7 min read",
    "minutes": 6.445,
    "time": 386700,
    "words": 1289
  },
  "slug": "posts/advent-of-code-assembly",
  "slugAsParams": "advent-of-code-assembly",
  "url": "/posts/advent-of-code-assembly",
  "slugs": "posts/advent-of-code-assembly"
}